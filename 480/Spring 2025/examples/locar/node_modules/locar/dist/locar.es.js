var j = (r) => {
  throw TypeError(r);
};
var F = (r, t, e) => t.has(r) || j("Cannot " + e);
var n = (r, t, e) => (F(r, t, "read from private field"), e ? e.call(r) : t.get(r)), m = (r, t, e) => t.has(r) ? j("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, e), d = (r, t, e, i) => (F(r, t, "write to private field"), i ? i.call(r, e) : t.set(r, e), e), v = (r, t, e) => (F(r, t, "access private method"), e);
var q = (r, t, e, i) => ({
  set _(o) {
    d(r, t, o, e);
  },
  get _() {
    return n(r, t, i);
  }
});
import * as f from "three";
import { Vector3 as Z, Euler as N, Quaternion as _, EventDispatcher as B, MathUtils as D } from "three";
var P, U, G, X, Q;
class K {
  /**
   * Create a SphMercProjection.
   */
  constructor() {
    m(this, P);
    this.EARTH = 4007501668e-2, this.HALF_EARTH = 2003750834e-2;
  }
  /**
   * Project a longitude and latitude into Spherical Mercator.
   * @param {number} lon - the longitude.
   * @param {number} lat - the latitude.
   * @return {Array} Two-member array containing easting and northing.
   */
  project(t, e) {
    return [v(this, P, U).call(this, t), v(this, P, G).call(this, e)];
  }
  /**
   * Unproject a Spherical Mercator easting and northing.
   * @param {Array} projected - Two-member array containing easting and northing
   * @return {Array} Two-member array containing longitude and latitude 
   */
  unproject(t) {
    return [v(this, P, X).call(this, t[0]), v(this, P, Q).call(this, t[1])];
  }
  /**
   * Return the projection's ID.
   * @return {string} The value "epsg:3857".
   */
  getID() {
    return "epsg:3857";
  }
}
P = new WeakSet(), U = function(t) {
  return t / 180 * this.HALF_EARTH;
}, G = function(t) {
  var e = Math.log(Math.tan((90 + t) * Math.PI / 360)) / (Math.PI / 180);
  return e * this.HALF_EARTH / 180;
}, X = function(t) {
  return t / this.HALF_EARTH * 180;
}, Q = function(t) {
  var e = t / this.HALF_EARTH * 180;
  return e = 180 / Math.PI * (2 * Math.atan(Math.exp(e * Math.PI / 180)) - Math.PI / 2), e;
};
var R, A, T, x, L, C, E, I, b, O, p, S, V, W, Y;
class st {
  /**
   * @param {THREE.Scene} scene - The Three.js scene to use.
   * @param {THREE.Camera} camera - The Three.js camera to use. Should usually 
   * be a THREE.PerspectiveCamera.
   * @param {Object} options - Initialisation options for the GPS; see
   * setGpsOptions() below.
   * @param {Object} serverLogger - an object which can optionally log GPS position to a server for debugging. null by default, so no logging will be done. This object should implement a sendData() method to send data (2nd arg) to a given endpoint (1st arg). Please see source code for details. Ensure you comply with privacy laws (GDPR or equivalent) if implementing this.
   */
  constructor(t, e, i = {}, o = null) {
    m(this, p);
    m(this, R);
    m(this, A);
    m(this, T);
    m(this, x);
    m(this, L);
    m(this, C);
    m(this, E);
    m(this, I);
    m(this, b);
    m(this, O);
    this.scene = t, this.camera = e, d(this, R, new K()), d(this, A, {}), d(this, T, null), d(this, x, 0), d(this, L, 100), d(this, C, null), this.setGpsOptions(i), d(this, E, null), d(this, I, 0), d(this, b, 0), d(this, O, o);
  }
  /**
   * Set the projection to use.
   * @param {Object} any object which includes a project() method 
   * taking longitude and latitude as arguments and returning an array 
   * containing easting and northing.
   */
  setProjection(t) {
    d(this, R, t);
  }
  /**
   * Set the GPS options.
   * @param {Object} object containing gpsMinDistance and/or gpsMinAccuracy
   * properties. The former specifies the number of metres which the device
   * must move to process a new GPS reading, and the latter specifies the 
   * minimum accuracy, in metres, for a GPS reading to be counted.
   */
  setGpsOptions(t = {}) {
    t.gpsMinDistance !== void 0 && d(this, x, t.gpsMinDistance), t.gpsMinAccuracy !== void 0 && d(this, L, t.gpsMinAccuracy);
  }
  /**
   * Start the GPS on a real device
   * @return {boolean} code indicating whether the GPS was started successfully.
   * GPS errors can be handled by handling the gpserror event.
   */
  async startGps() {
    if (n(this, O)) {
      const e = await (await n(this, O).sendData("/gps/start", {
        gpsMinDistance: n(this, x),
        gpsMinAccuracy: n(this, L)
      })).json();
      d(this, b, e.session);
    }
    return n(this, C) === null ? (d(this, C, navigator.geolocation.watchPosition(
      (t) => {
        v(this, p, W).call(this, t);
      },
      (t) => {
        n(this, A).gpserror ? n(this, A).gpserror(t.code) : alert(`GPS error: code ${t.code}`);
      },
      {
        enableHighAccuracy: !0
      }
    )), !0) : !1;
  }
  /**
   * Stop the GPS on a real device
   * @return {boolean} true if the GPS was stopped, false if it could not be
   * stopped (i.e. it was never started).
   */
  stopGps() {
    return n(this, C) !== null ? (navigator.geolocation.clearWatch(n(this, C)), d(this, C, null), !0) : !1;
  }
  /**
   * Send a fake GPS signal. Useful for testing on a desktop or laptop.
   * @param {number} lon - The longitude.
   * @param {number} lat - The latitude.
   * @param {number} elev - The elevation in metres. (optional, set to null
   * for no elevation).
   * @param {number} acc - The accuracy of the GPS reading in metres. May be
   * ignored if lower than the specified minimum accuracy.
   */
  fakeGps(t, e, i = null, o = 0) {
    i !== null && this.setElevation(i), v(this, p, W).call(this, {
      coords: {
        longitude: t,
        latitude: e,
        accuracy: o
      }
    });
  }
  /**
   * Convert longitude and latitude to three.js/WebGL world coordinates.
   * Uses the specified projection, and negates the northing (in typical
   * projections, northings increase northwards, but in the WebGL coordinate
   * system, we face negative z if the camera is at the origin with default
   * rotation).
   * @param {number} lon - The longitude.
   * @param {number} lat - The latitude.
   * @return {Array} a two member array containing the WebGL x and z coordinates
   */
  lonLatToWorldCoords(t, e) {
    const i = n(this, R).project(t, e);
    if (n(this, E))
      i[0] -= n(this, E)[0], i[1] -= n(this, E)[1];
    else
      throw "No initial position determined";
    return [i[0], -i[1]];
  }
  /**
   * Add a new AR object at a given latitude, longitude and elevation.
   * @param {THREE.Mesh} object the object
   * @param {number} lon - the longitude.
   * @param {number} lat - the latitude.
   * @param {number} elev - the elevation in metres 
   * (if not specified, 0 is assigned)
   * @param {Object} properties - properties describing the object (for example,
   * the contents of the GeoJSON properties field).
   */
  add(t, e, i, o, u = {}) {
    var g;
    t.properties = u, v(this, p, S).call(this, t, e, i, o), this.scene.add(t), (g = n(this, O)) == null || g.sendData("/object/new", {
      position: t.position,
      x: t.position.x,
      z: t.position.z,
      session: n(this, b),
      properties: u
    });
  }
  /**
   * Set the elevation (y coordinate) of the camera.
   * @param {number} elev - the elevation in metres.
   */
  setElevation(t) {
    this.camera.position.y = t;
  }
  /**
   * Add an event handler.
   * Currently-understood events: "gpsupdate" and "gpserror".
   * The former fires when a GPS update is received, and is passed the
   * standard Geolocation API position object, along with the distance moved
   * since the last GPS update in metres.
   * The latter fires when a GPS error is generated, and is passed the
   * standard Geolocation API numerical error code.
   * @param {string} eventName - the event to handle.
   * @param {Function} eventHandler - the event handler function.
   * @listens LocationBased#gpsupdate
   * @listens LocationBased#gpserror
   */
  on(t, e) {
    n(this, A)[t] = e;
  }
}
R = new WeakMap(), A = new WeakMap(), T = new WeakMap(), x = new WeakMap(), L = new WeakMap(), C = new WeakMap(), E = new WeakMap(), I = new WeakMap(), b = new WeakMap(), O = new WeakMap(), p = new WeakSet(), S = function(t, e, i, o) {
  const u = this.lonLatToWorldCoords(e, i);
  o !== void 0 && (t.position.y = o), [t.position.x, t.position.z] = u;
}, V = function(t, e) {
  d(this, E, n(this, R).project(t, e));
}, W = function(t) {
  var i, o, u;
  let e = Number.MAX_VALUE;
  q(this, I)._++, (i = n(this, O)) == null || i.sendData("/gps/new", {
    gpsCount: n(this, I),
    lat: t.coords.latitude,
    lon: t.coords.longitude,
    acc: t.coords.accuracy,
    session: n(this, b)
  }), t.coords.accuracy <= n(this, L) && (n(this, T) === null ? d(this, T, {
    latitude: t.coords.latitude,
    longitude: t.coords.longitude
  }) : e = v(this, p, Y).call(this, n(this, T), t.coords), e >= n(this, x) && (n(this, T).longitude = t.coords.longitude, n(this, T).latitude = t.coords.latitude, n(this, E) || (v(this, p, V).call(this, t.coords.longitude, t.coords.latitude), (o = n(this, O)) == null || o.sendData("/worldorigin/new", {
    gpsCount: n(this, I),
    lat: t.coords.latitude,
    lon: t.coords.longitude,
    session: n(this, b),
    initialPosition: n(this, E)
  })), v(this, p, S).call(this, this.camera, t.coords.longitude, t.coords.latitude), (u = n(this, O)) == null || u.sendData("/gps/accepted", {
    gpsCount: n(this, I),
    cameraX: this.camera.position.x,
    cameraZ: this.camera.position.z,
    session: n(this, b),
    distMoved: e
  }), n(this, A).gpsupdate && n(this, A).gpsupdate(t, e)));
}, /**
 * Calculate haversine distance between two lat/lon pairs.
 *
 * Taken from original A-Frame AR.js location-based components
 */
Y = function(t, e) {
  const i = f.MathUtils.degToRad(e.longitude - t.longitude), o = f.MathUtils.degToRad(e.latitude - t.latitude), u = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(f.MathUtils.degToRad(t.latitude)) * Math.cos(f.MathUtils.degToRad(e.latitude)) * (Math.sin(i / 2) * Math.sin(i / 2));
  return 2 * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)) * 6371e3;
};
class ot {
  /**
   * Create a WebcamRenderer.
   * @param {THREE.WebGLRenderer} renderer - the Three.js renderer.
   * @param {string} videoElementSelector - selector to obtain the HTML video 
   * element to render the webcam feed. If a falsy value (e.g. null or 
   * undefined), a video element will be created.
   * @options {Object} - options to use for initialising the camera. Currently
   * width and height properties are understood.
   */
  constructor(t, e, i) {
    this.renderer = t, this.renderer.autoClear = !1, this.sceneWebcam = new f.Scene();
    let o;
    e ? o = document.querySelector(e) : (o = document.createElement("video"), o.setAttribute("autoplay", !0), o.setAttribute("playsinline", !0), o.style.display = "none", document.body.appendChild(o)), this.geom = new f.PlaneGeometry(), this.texture = new f.VideoTexture(o), this.material = new f.MeshBasicMaterial({ map: this.texture });
    const u = new f.Mesh(this.geom, this.material);
    if (this.sceneWebcam.add(u), this.cameraWebcam = new f.OrthographicCamera(
      -0.5,
      0.5,
      0.5,
      -0.5,
      0,
      10
    ), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      const g = {
        video: {
          width: (i == null ? void 0 : i.width) || 1280,
          height: (i == null ? void 0 : i.height) || 720,
          facingMode: "environment"
        }
      };
      navigator.mediaDevices.getUserMedia(g).then((w) => {
        console.log("using the webcam successfully..."), o.srcObject = w, o.play();
      }).catch((w) => {
        setTimeout(() => {
          alert(
            `Webcam Error
Name: ` + w.name + `
Message: ` + w.message
          );
        }, 1e3);
      });
    } else
      setTimeout(() => {
        alert("sorry - media devices API not supported");
      }, 1e3);
  }
  /**
   * Update the webcam.
   * Should be called from your Three.js rendering (animation) function.
   */
  update() {
    this.renderer.clear(), this.renderer.render(this.sceneWebcam, this.cameraWebcam), this.renderer.clearDepth();
  }
  /**
   * Free up the memory associated with the webcam.
   * Should be called when your application closes.
   */
  dispose() {
    this.material.dispose(), this.texture.dispose(), this.geom.dispose();
  }
}
const k = navigator.userAgent.match(/iPhone|iPad|iPod/i) || /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints != null && navigator.maxTouchPoints > 1, $ = new Z(0, 0, 1), z = new N(), J = new _(), tt = new _(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), et = { type: "change" };
class at extends B {
  /**
   * Create an instance of DeviceOrientationControls.
   * @param {Object} object - the object to attach the controls to
   * (usually your Three.js camera)
   */
  constructor(t) {
    super(), window.isSecureContext === !1 && console.error(
      "THREE.DeviceOrientationControls: DeviceOrientationEvent is only available in secure contexts (https)"
    );
    const e = this, i = 1e-6, o = new _();
    this.object = t, this.object.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = null, this.screenOrientation = 0, this.alphaOffset = 0, this.initialOffset = null, this.TWO_PI = 2 * Math.PI, this.HALF_PI = 0.5 * Math.PI, this.orientationChangeEventName = "ondeviceorientationabsolute" in window ? "deviceorientationabsolute" : "deviceorientation", this.smoothingFactor = 1;
    const u = function({
      alpha: s,
      beta: c,
      gamma: h,
      webkitCompassHeading: a
    }) {
      if (k) {
        const l = 360 - a;
        e.alphaOffset = D.degToRad(l - s), e.deviceOrientation = { alpha: s, beta: c, gamma: h, webkitCompassHeading: a };
      } else
        s < 0 && (s += 360), e.deviceOrientation = { alpha: s, beta: c, gamma: h };
      window.dispatchEvent(
        new CustomEvent("camera-rotation-change", {
          detail: { cameraRotation: t.rotation }
        })
      );
    }, g = function() {
      e.screenOrientation = window.orientation || 0;
    }, w = function(s, c, h, a, l) {
      z.set(h, c, -a, "YXZ"), s.setFromEuler(z), s.multiply(tt), s.multiply(J.setFromAxisAngle($, -l));
    };
    this.connect = function() {
      g(), window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then((s) => {
        s === "granted" && (window.addEventListener(
          "orientationchange",
          g
        ), window.addEventListener(
          e.orientationChangeEventName,
          u
        ));
      }).catch(function(s) {
        console.error(
          "THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:",
          s
        );
      }) : (window.addEventListener(
        "orientationchange",
        g
      ), window.addEventListener(
        e.orientationChangeEventName,
        u
      )), e.enabled = !0;
    }, this.disconnect = function() {
      window.removeEventListener(
        "orientationchange",
        g
      ), window.removeEventListener(
        e.orientationChangeEventName,
        u
      ), e.enabled = !1, e.initialOffset = !1, e.deviceOrientation = null;
    }, this.update = function({ theta: s = 0 } = { theta: 0 }) {
      if (e.enabled === !1) return;
      const c = e.deviceOrientation;
      if (c) {
        let h = c.alpha ? D.degToRad(c.alpha) + e.alphaOffset : 0, a = c.beta ? D.degToRad(c.beta) : 0, l = c.gamma ? D.degToRad(c.gamma) : 0;
        const H = e.screenOrientation ? D.degToRad(e.screenOrientation) : 0;
        if (k) {
          const y = new _();
          w(y, h, a, l, H);
          const M = new N().setFromQuaternion(
            y,
            "YXZ"
          );
          console.log(M.x, M.y, M.z), M.y = D.degToRad(
            360 - c.webkitCompassHeading
          ), y.setFromEuler(M), e.object.quaternion.copy(y);
        } else {
          if (this.smoothingFactor < 1) {
            if (this.lastOrientation) {
              const y = this.smoothingFactor;
              h = this._getSmoothedAngle(
                h,
                this.lastOrientation.alpha,
                y
              ), a = this._getSmoothedAngle(
                a + Math.PI,
                this.lastOrientation.beta,
                y
              ), l = this._getSmoothedAngle(
                l + this.HALF_PI,
                this.lastOrientation.gamma,
                y,
                Math.PI
              );
            } else
              a += Math.PI, l += this.HALF_PI;
            this.lastOrientation = {
              alpha: h,
              beta: a,
              gamma: l
            };
          }
          w(
            e.object.quaternion,
            h + s,
            this.smoothingFactor < 1 ? a - Math.PI : a,
            this.smoothingFactor < 1 ? l - this.HALF_PI : l,
            H
          );
        }
        8 * (1 - o.dot(e.object.quaternion)) > i && (o.copy(e.object.quaternion), e.dispatchEvent(et));
      }
    }, this._orderAngle = function(s, c, h = this.TWO_PI) {
      return c > s && Math.abs(c - s) < h / 2 || s > c && Math.abs(c - s) > h / 2 ? { left: s, right: c } : { left: c, right: s };
    }, this._getSmoothedAngle = function(s, c, h, a = this.TWO_PI) {
      const l = this._orderAngle(s, c, a), H = l.left, y = l.right;
      l.left = 0, l.right -= H, l.right < 0 && (l.right += a);
      let M = y == c ? (1 - h) * l.right + h * l.left : h * l.right + (1 - h) * l.left;
      return M += H, M >= a && (M -= a), M;
    }, this.updateAlphaOffset = function() {
      e.initialOffset = !1;
    }, this.dispose = function() {
      e.disconnect();
    }, this.getAlpha = function() {
      const { deviceOrientation: s } = e;
      return s && s.alpha ? D.degToRad(s.alpha) + e.alphaOffset : 0;
    }, this.getBeta = function() {
      const { deviceOrientation: s } = e;
      return s && s.beta ? D.degToRad(s.beta) : 0;
    }, window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? this.initPermissionDialog() : this.connect();
  }
  // Provide gesture before initialising device orientation controls
  // From PR #659 on the main AR.js repo
  // Thanks to @ma2yama
  initPermissionDialog() {
    const t = document.createElement("div"), e = document.createElement("div"), i = document.createElement("div"), o = document.createElement("div");
    document.body.appendChild(t);
    const u = {
      display: "flex",
      position: "fixed",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      zIndex: 1,
      backgroundColor: "rgba(0,0,0,0.6)",
      justifyContent: "center",
      alignItems: "center"
    }, g = {
      backgroundColor: "white",
      padding: "6px",
      borderRadius: "3px",
      width: "36rem",
      height: "24rem"
    }, w = {
      width: "100%",
      height: "70%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }, s = {
      display: "inline-flex",
      width: "100%",
      height: "30%",
      justifyContent: "center",
      alignItems: "center"
    };
    for (let a in u)
      t.style[a] = u[a];
    for (let a in g)
      e.style[a] = g[a];
    for (let a in w)
      i.style[a] = w[a];
    for (let a in s)
      o.style[a] = s[a];
    t.appendChild(e), e.appendChild(i), e.appendChild(o), i.innerHTML = '<div style="font-size: 24pt; margin: 1rem;">This immersive website requires access to your device motion sensors.</div>';
    const c = () => {
      this.connect(), t.style.display = "none";
    }, h = document.createElement("button");
    h.addEventListener("click", c), h.style.width = "50%", h.style.height = "80%", h.style.fontSize = "20pt", h.appendChild(document.createTextNode("OK")), o.appendChild(h), document.body.appendChild(t);
  }
}
class rt {
  /**
   * Create a ClickHandler.
   * @param {THREE.WebGLRenderer} - The Three.js renderer on which the click
   * events will be handled.
   */
  constructor(t) {
    this.raycaster = new f.Raycaster(), this.normalisedMousePosition = new f.Vector2(null, null), t.domElement.addEventListener("click", (e) => {
      this.normalisedMousePosition.set(
        e.clientX / t.domElement.clientWidth * 2 - 1,
        -(e.clientY / t.domElement.clientHeight * 2) + 1
      );
    });
  }
  /**
   * Cast a ray into the scene to detect objects.
   * @param {THREE.Camera} - The active Three.js camera, from which the ray
   * will be cast.
   * @param {THREE.Scene} - The active Three.js scene, which the ray will be
   * cast into.
   * @return {Array} - array of all intersected objects.
   */
  raycast(t, e) {
    if (this.normalisedMousePosition.x !== null && this.normalisedMousePosition.y !== null) {
      this.raycaster.setFromCamera(this.normalisedMousePosition, t);
      const i = this.raycaster.intersectObjects(e.children, !1);
      return this.normalisedMousePosition.set(null, null), i;
    }
    return [];
  }
}
export {
  rt as ClickHandler,
  at as DeviceOrientationControls,
  st as LocationBased,
  K as SphMercProjection,
  ot as WebcamRenderer
};
